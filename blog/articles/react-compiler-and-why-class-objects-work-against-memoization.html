<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width,initial-scale=1"> <meta name="application-name" content="Anita"> <meta name="msapplication-TileColor" content="#002346"> <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/favicon/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon/favicon-16x16.png"> <link rel="manifest" href="/assets/icons/favicon/site.webmanifest"> <link rel="mask-icon" href="/assets/icons/favicon/safari-pinned-tab.svg" color="#5bbad5"> <link rel="shortcut icon" href="/assets/icons/favicon/favicon.ico"> <meta name="msapplication-TileColor" content="#da532c"> <meta name="msapplication-config" content="/assets/icons/favicon/browserconfig.xml"> <meta name="theme-color" content="#002346"> <link rel="stylesheet" href="/assets/css/styles-0-21-0.min.css"> <title>React Compiler and why class objects can work against memoization</title> <meta name="description" content="React Compiler removes a lot of manual memoization, but class instances can still trigger avoidable recomputation when dependency tracking falls back to object identity."> </head> <body class="text-gray-800 antialiased flex flex-col h-screen justify-between"> <nav class="top-0 absolute z-50 w-full flex flex-wrap items-center justify-between py-3 navbar-expand-lg bg-gradient-to-r from-prussian-blue-400 to-prussian-blue-700"> <div class="container px-4 mx-auto flex flex-wrap items-center justify-between z-50"> <div class="w-full relative flex justify-between lg:w-auto lg:static lg:block lg:justify-start"> <div class="flex-grow relative flex items-center lg:w-auto lg:static"> <a class="text-lg font-bold leading-relaxed inline-block mr-4 py-2 whitespace-no-wrap uppercase text-white" href="/"> <img src="/assets/logo/logo_square.svg" style="height:35px;width:auto" alt="Anita"> </a> <a class="text-lg font-bold leading-relaxed inline-block mr-4 py-2 whitespace-no-wrap uppercase text-white" href="/"> Anita </a> </div> <button class="cursor-pointer text-xl leading-none px-3 py-1 border border-solid border-transparent rounded bg-transparent block lg:hidden outline-none focus:outline-none" type="button" onclick='toggleNavbar("main-collapse-navbar")'> <ion-icon name="menu-outline" class="text-white" style="width:1.5em;height:1.5em"></ion-icon> </button> </div> <div class="lg:flex flex-grow items-center bg-white lg:bg-transparent lg:shadow-none hidden" id="main-collapse-navbar"> <ul class="flex flex-col lg:flex-row list-none lg:ml-auto"> <li class="flex items-center"> <a class="lg:text-white lg:hover:text-gray-300 text-gray-800 px-3 py-4 lg:py-2 flex items-center text-xs uppercase font-bold" href="/blog"> Blog </a> </li> <li class="flex items-center"> <a class="lg:text-white lg:hover:text-gray-300 text-gray-800 px-3 py-4 lg:py-2 flex items-center text-xs uppercase font-bold" href="https://github.com/anita-app/anita"> <span class="inline-block mr-2">Source Code</span> <ion-icon name="logo-github" class="lg:text-gray-300 text-gray-500" style="width:1.5em;height:1.5em"></ion-icon> </a> </li> </ul> </div> </div> </nav> <section class="relative"> <div class="mx-auto pb-20 mt-36 mb-36"> <div class="w-full max-w-3xl ml-auto mr-auto py-10 px-6 sm:px-8 md:px-0"> <article> <div class="pt-2 pb-1 pr-5 border-b rounded-t"> <h1 class="block text-center font-light leading-8 tracking-tight text-gray-900 text-4xl pb-6">React Compiler and why class objects can work against memoization</h1> <span class="text-sm text-gray-400">Article</span> </div> <p class="text-sm text-gray-500 mb-8 mt-1">Published on February 6, 2026 by ilDon </p> <figure class="mb-10 mt-10"> <img class="w-full rounded-lg mx-auto" src="/assets/images/blog/react-compiler-and-why-class-objects-work-against-memoization/react-compiler-and-why-class-objects-work-against-memoization.jpg" alt="" width="1310" height="873"> </figure> <aside class="ai-assisted-notice">This article reflects the author's own ideas and reasoning. Since the author is not a native English speaker, AI was used to edit the final wording for clarity and correctness.</aside> <div class="prose prose-lg prose-prussian-blue mx-auto mt-6 text-gray-500 max-w-none"> <p>React Compiler is now stable and production-ready (React blog, October 7, 2025), and it significantly reduces the need for manual <code>useMemo</code>, <code>useCallback</code>, and <code>React.memo</code>.</p> <p>This is great news for most React codebases, especially those with clean function components and immutable data. But there is one pattern that becomes increasingly awkward: class-heavy object models with methods that compute derived values.</p> <p>If your render-time logic depends on class instances, compiler memoization can become less precise than you want, and you often end up re-introducing manual memoization just to recover control.</p> <h2 id="reactcompileroptimizesbyobservabledependencies">React Compiler optimizes by observable dependencies</h2> <p>The official docs explain that React Compiler automatically memoizes components and values based on static analysis and heuristics:</p> <ul> <li><a href="https://react.dev/learn/react-compiler/introduction">React Compiler Introduction</a></li> <li><a href="https://react.dev/blog/2025/10/07/react-compiler-1">React Compiler v1.0 blog post</a></li> </ul> <p>The key detail is this: memoization still depends on what React can observe as inputs.</p> <p>In React, memoized comparisons are reference-based for objects (<code>Object.is</code> semantics). The <code>memo</code> and <code>useMemo</code> docs both make this explicit:</p> <ul> <li><a href="https://react.dev/reference/react/memo">memo</a></li> <li><a href="https://react.dev/reference/react/useMemo">useMemo</a></li> </ul> <p>So if the meaningful value is hidden inside an object instance, and that instance reference changes, React has to assume the value changed too.</p> <h2 id="elementclassexample"><code>ElementClass</code> example</h2> <p>Suppose you model an element like this:</p> <div class="code-block"><pre class="d"><code>class ElementClass {
  constructor(private readonly isoDate: string) {}

  public getFormattedDate(): string {
    const date = new Date(this.isoDate);

    if (Number.isNaN(date.getTime())) {
      return 'Invalid date';
    }

    return date.toLocaleString('en-US', {
      year: 'numeric',
      month: 'short',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      timeZoneName: 'short',
    });
  }
}
</code></pre></div> <p>And in a component:</p> <div class="code-block"><pre class="d"><code>export function Row({ elementInstance }: { elementInstance: ElementClass }) {
  const formattedDate = elementInstance.getFormattedDate();
  return &lt;span&gt;{formattedDate}&lt;/span&gt;;
}
</code></pre></div> <p>This is readable. But from the outside, the relevant reactive input is effectively <code>elementInstance</code> (the object reference).</p> <p>If your state management layer returns a new <code>ElementClass</code> instance, React/Compiler sees a new dependency and the formatted value is recomputed, even when the underlying <code>isoDate</code> string did not change.</p> <h2 id="themanualescapehatchworksbutitisnoisy">The manual escape hatch works, but it is noisy</h2> <p>You can force a narrower dependency:</p> <div class="code-block"><pre class="d"><code>class ElementClass {
  constructor(public readonly isoDate: string) {} // &lt;-- expose isoDate as a public property
  // unchanged
}

export function Row({ elementInstance }: { elementInstance: ElementClass }) {
  const formattedDate = useMemo(
    () =&gt; elementInstance.getFormattedDate(),
    [elementInstance.isoDate],
  );

  return &lt;span&gt;{formattedDate}&lt;/span&gt;;
}
</code></pre></div> <p>This is valid, and React explicitly documents <code>useMemo</code>/<code>useCallback</code> as escape hatches even with the compiler:</p> <ul> <li><a href="https://react.dev/blog/2025/10/07/react-compiler-1#what-should-i-do-about-usememo-usecallback-and-reactmemo">What should I do about useMemo, useCallback, and React.memo?</a></li> </ul> <p>But at this point, we are doing manual dependency plumbing again, plus we had to expose internals to the UI.</p> <h2 id="acompilerfriendlyalternativeplaindatapurehelpers">A compiler-friendly alternative: plain data + pure helpers</h2> <p>If the UI receives plain immutable data, dependencies become explicit and cheap:</p> <div class="code-block"><pre class="d"><code>type Element = {
  isoDate: string;
};

export function Row({ element }: { element: Element }) {
  const formattedDate = DateHelpers.formatDate(element.isoDate);
  return &lt;span&gt;{formattedDate}&lt;/span&gt;;
}
</code></pre></div> <p>Now the relevant input of <code>DateHelpers.formatDate</code> is a primitive (<code>isoDate</code>), not hidden state behind a method call on a class instance. In this way, the output of <code>formatDate</code> can be memoized by the compiler taking <code>isoDate</code> as the only dependency, which is a primitive value that will trigger memoization correctly when it changes.</p> <p>One could object that, even in this example with a simple object, the entire <code>element</code> is still passed down to the component. As a result, <code>Row</code> will be re-rendered anyway; the only real difference is that <code>formattedDate</code> is no longer recomputed.</p> <p>This is true: if you pass a whole object and its reference changes, that component re-renders. We will get to that in a moment.</p> <p>Before exploring the solution to that problem, I want to highlight that on large apps, the difference between class instances and plain data can still be significant, even if considering only the memoization of derived values. React Compiler injects memoization cells and dependency checks. If your dependencies are unstable object references, cache hit rate is low:</p> <ol> <li>you still pay extra memory for memoization slots,</li> <li>you still run dependency checks,</li> <li>you still recompute because references change.</li> </ol> <p>In other words, with class-instance-heavy render paths and no manual memoization, <strong>compiler optimizations can become mostly overhead instead of a performance win</strong>.</p> <p>Now, back to the problem of passing a whole object. If you pass an object and its reference changes, the component re-renders. This is true regardless of whether the object is a class instance or a plain object. if you want to avoid unnecessary re-renders caused by object reference changes, you can pass only the primitive that the child actually needs, instead of the whole object. This way, the component will only re-render when the relevant primitive value changes, and not when the object reference changes:</p> <div class="code-block"><pre class="d"><code>export function Row({ isoDate }: { isoDate: string }) {
  const formattedDate = DateHelpers.formatIsoDate(isoDate);
  return &lt;span&gt;{formattedDate}&lt;/span&gt;;
}
</code></pre></div> <p>Now the dependency is explicit and primitive (<code>isoDate</code>) instead of hidden behind instance methods.</p> <p>A possible objection is that, even when using an object-oriented approach, one could still pass to the child component the result of <code>element.getFormattedDate()</code>, which is again just a string:</p> <div class="code-block"><pre class="d"><code>function Parent({ element }: { element: ElementClass }) {
  return &lt;Row formattedDate={element.getFormattedDate()} /&gt;;
}

function Row({ formattedDate }: { formattedDate: string }) {
  return &lt;span&gt;{formattedDate}&lt;/span&gt;;
}
</code></pre></div> <p><code>Row</code> now receives a primitive prop, but the expensive or repeated computation has simply moved one level up, into <code>Parent</code>.</p> <p>If <code>element</code> changes by reference frequently, <code>element.getFormattedDate()</code> is still re-executed frequently. So the bottleneck is not removed, only relocated.</p> <p>With a data-first shape, you can pass <code>isoDate</code> directly across boundaries and keep derivations as pure functions close to where they are needed.</p> <p>This aligns much better with React's purity and immutability model:</p> <ul> <li><a href="https://react.dev/reference/rules/components-and-hooks-must-be-pure">Components and Hooks must be pure</a></li> <li><a href="https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability">immutability lint rule</a></li> </ul> <h2 id="practicalruleofthumb">Practical rule of thumb</h2> <p>Inside React render paths, prefer data-first models over behavior-rich class instances.</p> <p>Use classes at boundaries if they add value (domain, parsing, adapters), but pass serializable plain data to components and keep render-time derivations as pure functions.</p> <p>With React Compiler, this usually gives you:</p> <ol> <li>better automatic memoization hit rate,</li> <li>fewer manual <code>useMemo</code> escape hatches,</li> <li>clearer dependency reasoning,</li> <li>less accidental recomputation caused by object identity churn.</li> </ol> <p>React Compiler removes a lot of optimization work, but it still rewards code where dependencies are explicit. For UI rendering in modern React, plain objects plus pure helper functions are often the more scalable choice.</p> </div> </article> <div class="flex justify-center mt-10"> <a class="bg-blue-500 hover:bg-blue-700 text-white py-4 px-6 rounded" href="/app"> <span class="font-bold text-2xl">Get started</span><sup class="text-xs">Beta</sup> </a> </div> </div> </div> </section> <footer class="relative bg-gray-300 pt-8 pb-6"> <div class="bottom-auto top-0 left-0 right-0 w-full absolute pointer-events-none overflow-hidden -mt-20" style="height:80px;transform:translateZ(0)"> <svg class="absolute bottom-0 overflow-hidden" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none" version="1.1" viewBox="0 0 2560 100" x="0" y="0"> <polygon class="text-gray-300 fill-current" points="2560 0 2560 100 0 100"></polygon> </svg> </div> <div class="container mx-auto px-4"> <div class="flex flex-wrap items-center md:justify-left justify-left"> <div class="w-2/12 md:w-3/12"> <button class="bg-white text-gray-900 shadow-lg font-normal h-10 w-10 items-center justify-center align-center rounded-full outline-none focus:outline-none mr-2" onclick='window.open("https://github.com/anita-app/anita","_blank")'> <ion-icon name="logo-github" class="mt-1" style="width:1.5em;height:1.5em"></ion-icon> </button> </div> <div class="column-1 w-10/12 md:w-6/12 text-right md:text-center py-1"> <div class="flex justify-end md:justify-center text-sm text-gray-600 font-semibold flex-wrap"> Developed with <ion-icon name="heart-outline" class="text-red-800 self-end ml-1 mr-1" style="width:1.2em;height:1.2em"></ion-icon> by humans & <a href="https://copilot.github.com/" target="_blank" class="ml-1"><u>GitHub Copilot</u></a>, </div> <div class="flex justify-end md:justify-center text-sm text-gray-600 font-semibold flex-wrap"> made possible by <a href="/licenses.html" class="ml-1"><u>open source</u></a>. </div> </div> </div> </div> <script src="/assets/js/main-0-21-0.min.js"></script> <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script> <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script> <script data-goatcounter="https://anita.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> </footer> </body> </html> 